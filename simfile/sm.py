from msdparser import MSDParser

from .base import BaseChart, BaseCharts, BaseSimfile
from ._private.property import attr_property
from ._private.serializable import Serializable


__all__ = ['SMChart', 'SMCharts', 'SMSimfile']


class SMChart(BaseChart):
    """
    The Chart class represents chart metadata through its attributes.

    Chart objects can be created from lists, mappings (i.e. dicts), and other
    Chart objects. Lists should be of the form [stepstype, description,
    difficulty, meter, radarvalues, notes]; mappings should have those items as keys.
    Creating a Chart from an existing Chart will clone it, including its
    `notes` attribute. During construction, types are coerced where necessary.

    `stepstype` is a string indicating the game mode of the chart.
    "dance-single" and "dance-double" are two common values.

    `description` can be set to any string. It is often set to the chart
    author's name.

    `difficulty` is a string indicating which difficulty slot the chart goes
    under -- traditionally one of "Beginner", "Easy", "Medium", "Hard",
    "Challenge", or "Edit", although this is not enforced.

    `meter` is an arbitrary positive integer that represents the chart's
    relative difficulty.

    `radarvalues` is a string generated by StepMania that tries
    to break down difficulty into five components, although it can be safely
    set to an empty string.

    `notes` is the note data as a string.
    """
    stepstype = attr_property('_stepstype', str)
    description = attr_property('_description', str)
    difficulty = attr_property('_difficulty', str)
    meter = attr_property('_meter', int)
    radarvalues = attr_property('_radarvalues', str)
    notes = attr_property('_notes', str)

    @Serializable.enable_string_output
    def serialize(self, file):
        file.write(
            f'#NOTES:\n'
            f'     {self.stepstype}:\n'
            f'     {self.description}:\n'
            f'     {self.difficulty}:\n'
            f'     {self.meter}:\n'
            f'     {self.radarvalues}:\n'
            f'{self.notes}\n'
            f';'
        )

    def __init__(self, string: str):
        values = string.split(':')
        if len(values) != 6:
            raise ValueError(f'expected 6 chart components, got {len(values)}')
        iterator = iter(values)
        self.stepstype = next(iterator).strip()
        self.description = next(iterator).strip()
        self.difficulty = next(iterator).strip()
        self.meter = int(next(iterator).strip())
        self.radarvalues = next(iterator).strip()
        self.notes = next(iterator).strip()

    def __eq__(self, other):
        return (type(self) is type(other) and
                self.stepstype == other.stepstype and
                self.description == other.description and
                self.difficulty == other.difficulty and
                self.meter == other.meter and
                self.radarvalues == other.radarvalues and
                self.notes == other.notes)


class SMCharts(BaseCharts[SMChart]):

    @property
    def supported_fields(self):
        return frozenset({'stepstype', 'description', 'difficulty', 'meter', 'radarvalues'})


class SMSimfile(BaseSimfile):

    def _parse(self):
        with MSDParser(file=self.file, string=self.string) as parser:
            self._charts = SMCharts()
            for (key, value) in parser:
                key = key.upper()
                if key == 'NOTES':
                    self._charts.append(SMChart(string=value))
                else:
                    self[key] = value
    
    @property
    def charts(self):
        return self._charts
