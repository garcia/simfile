from collections import OrderedDict

from .abstract import *
from .common import *
from msdparser import MSDParser


__all__ = ['SMChart', 'SMCharts', 'SMSimfile']


def _chart_property(private_name):

    @property
    def chart_property(self):
        return getattr(self, private_name)

    @chart_property.setter
    def chart_property(self, value):
        setattr(self, private_name, value)

    return chart_property


class SMChart(Chart):
    """
    The Chart class represents chart metadata through its attributes.

    Chart objects can be created from lists, mappings (i.e. dicts), and other
    Chart objects. Lists should be of the form [stepstype, description,
    difficulty, meter, radarvalues, notes]; mappings should have those items as keys.
    Creating a Chart from an existing Chart will clone it, including its
    `notes` attribute. During construction, types are coerced where necessary.

    `stepstype` is a string indicating the game mode of the chart.
    "dance-single" and "dance-double" are two common values.

    `description` can be set to any string. It is often set to the chart
    author's name.

    `difficulty` is a string indicating which difficulty slot the chart goes
    under -- traditionally one of "Beginner", "Easy", "Medium", "Hard",
    "Challenge", or "Edit", although this is not enforced.

    `meter` is an arbitrary positive integer that represents the chart's
    relative difficulty.

    `radarvalues` is a string generated by StepMania that tries
    to break down difficulty into five components, although it can be safely
    set to an empty string.

    `notes` is the note data as a string.
    """
    stepstype = _chart_property('_stepstype')
    description = _chart_property('_description')
    difficulty = _chart_property('_difficulty')
    meter = _chart_property('_meter')
    radarvalues = _chart_property('_radarvalues')
    notes = _chart_property('_notes')

    def serialize(self, file):
        file.write(
            f'#NOTES:\n'
            f'     {self.stepstype},\n'
            f'     {self.description},\n'
            f'     {self.difficulty},\n'
            f'     {self.meter},\n'
            f'     {self.radarvalues},\n'
            f'{self.notes}\n'
            f';'
        )

    def __init__(self, string: str):
        values = iter(string.split(':'))
        if len(values) != 6:
            raise ValueError(f'expected 6 chart components, got {len(values)}')
        self.stepstype = next(values).strip()
        self.description = next(values).strip()
        self.difficulty = next(values).strip()
        self.meter = int(next(values).strip())
        self.radarvalues = next(values).strip()
        self.notes = next(values).strip()

    def __eq__(self, other):
        return (type(self) is type(other) and
                self.stepstype == other.stepstype and
                self.description == other.description and
                self.difficulty == other.difficulty and
                self.meter == other.meter and
                self.radarvalues == other.radarvalues and
                self.notes == other.notes)


class SMCharts(Charts):

    @property
    def supported_fields(self):
        return frozenset({'stepstype', 'description', 'difficulty', 'meter', 'radarvalues'})


class SMSimfile(Simfile):

    def _parse(self):
        with MSDParser(file=self.file, string=self.string) as parser:
            self._charts = SMCharts()
            for (key, value) in parser:
                if key == 'NOTES':
                    self._charts.append(SMChart(string=value))
                else:
                    self[key] = value
    
    @property
    def charts(self):
        return self._charts
