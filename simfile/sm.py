import codecs
import collections
import copy
import io
import itertools
import os
from io import StringIO
from decimal import Decimal
from fractions import Fraction, gcd
from collections import OrderedDict

from .abstract import *
from .common import *
from .msd import MSDParser


__all__ = ['SMChart', 'SMCharts', 'SMSimfile']


def _chart_property(private_name):
    @property
    def chart_property(self):
        return getattr(self, private_name)
    @chart_property.setter
    def chart_property(self, value):
        setattr(self, private_name, value)
    return chart_property

class SMChart(Chart):
    """
    The Chart class represents chart metadata through its attributes.

    Chart objects can be created from lists, mappings (i.e. dicts), and other
    Chart objects. Lists should be of the form [stepstype, description,
    difficulty, meter, radar, notes]; mappings should have those items as keys.
    Creating a Chart from an existing Chart will clone it, including its
    `notes` attribute. During construction, types are coerced where necessary.

    `stepstype` is a string indicating the game mode of the chart.
    "dance-single" and "dance-double" are two common values.

    `description` can be set to any string. It is often set to the chart
    author's name.

    `difficulty` is a string indicating which difficulty slot the chart goes
    under -- traditionally one of "Beginner", "Easy", "Medium", "Hard",
    "Challenge", or "Edit", although this is not enforced.

    `meter` is an arbitrary positive integer that represents the chart's
    relative difficulty.

    `radar` is a string generated by StepMania that tries
    to break down difficulty into five components, although it can be safely
    set to an empty string.

    `notes` is the note data as a string.
    """
    LEADING_WHITESPACE = '\n     '

    stepstype = _chart_property('_stepstype')
    description = _chart_property('_description')
    difficulty = _chart_property('_difficulty')
    meter = _chart_property('_meter')
    radar = _chart_property('_radar')
    notes = _chart_property('_notes')

    @classmethod
    def from_msd(cls, msd):
        return cls(msd=msd)

    def to_msd(self):
        yield ('NOTES',
            SMChart.LEADING_WHITESPACE + self.stepstype,
            SMChart.LEADING_WHITESPACE + self.description,
            SMChart.LEADING_WHITESPACE + self.difficulty,
            SMChart.LEADING_WHITESPACE + str(self.meter),
            SMChart.LEADING_WHITESPACE + self.radar,
            '\n' + self.notes)

    def __init__(self, chart=None, msd=None):
        if not chart and not msd:
            return
        elif chart and msd:
            raise ValueError('too many arguments')
        elif chart:
            msd = chart.to_msd()
        
        # Expecting a single MSD parameter
        chart_parameter = next(msd)
        chart_values = iter(chart_parameter)
        # Discard first MSD value (NOTES marker)
        next(chart_values)
        self.stepstype = next(chart_values).strip()
        self.description = next(chart_values).strip()
        self.difficulty = next(chart_values).strip()
        self.meter = int(next(chart_values).strip())
        self.radar = next(chart_values).strip()
        self.notes = next(chart_values).strip()

    def __repr__(self):
        rtn = '<SMChart: {type} {difficulty} {meter}'.format(
            type=self.stepstype,
            difficulty=self.difficulty,
            meter=self.meter,
        )
        if self.description:
            rtn += ' (%s)' % self.description
        return rtn + '>'

    def __eq__(self, other):
        return (self.stepstype == other.stepstype
            and self.description == other.description
            and self.difficulty == other.difficulty
            and self.meter == other.meter
            and self.radar == other.radar
            and self.notes == other.notes)


class SMCharts(ListWithRepr, Charts):
    """
    The Charts class provides methods for retrieving Chart objects.

    In addition to the `filter` and `get` methods, Charts objects can be
    iterated over or indexed like lists.
    """

    @property
    def supported_fields(self):
        return frozenset({'difficulty', 'stepstype', 'meter', 'description'})

    def to_msd(self):
        for chart in self:
            yield from chart.to_msd()

    @classmethod
    def from_msd(cls, msd):
        instance = cls()
        for parameter in msd:
            if parameter[0] != 'NOTES':
                continue
            else:
                instance.append(SMChart.from_msd_parameter(parameter))
        return instance


class SMParameters(OrderedDict, Parameters):
    def __init__(self):
        super().__init__()
    
    def to_msd(self):
        for param_name, param_value in self.items():
            if isinstance(param_value, MSDParameterEncodable):
                yield (param_name,) + tuple(param_value.to_msd_values())
            else:
                yield (param_name, param_value)
    
    @classmethod
    def from_msd(cls, msd):
        instance = cls()
        for parameter in msd:
            parameter_name = parameter[0].upper()
            if parameter_name == 'NOTES':
                continue
            elif parameter_name in ('BPMS', 'STOPS'):
                instance[parameter_name] = Timing.from_msd_values(parameter[1:])
            else:
                instance[parameter_name] = ':'.join(parameter[1:])
        return instance


def _parameter_property(parameter_name, cls=str):
    @property
    def parameter(self):
        if parameter_name in self.parameters:
            return cls(self.parameters[parameter_name])
    
    @parameter.setter
    def parameter(self, value):
        if not isinstance(value, cls):
            raise TypeError(parameter_name + ' should be a ' + cls.__name__)
        self.parameters[parameter_name] = value
    
    @parameter.deleter
    def parameter(self):
        del self.parameters[parameter_name]
    
    return parameter


class SMSimfile(Simfile):
    title = _parameter_property('TITLE')
    subtitle = _parameter_property('SUBTITLE')
    artist = _parameter_property('ARTIST')
    titletranslit = _parameter_property('TITLETRANSLIT')
    subtitletranslit = _parameter_property('SUBTITLETRANSLIT')
    artisttranslit = _parameter_property('ARTISTTRANSLIT')
    music = _parameter_property('MUSIC')
    samplestart = _parameter_property('SAMPLESTART', Decimal)
    samplelength = _parameter_property('SAMPLELENGTH', Decimal)
    bpms = _parameter_property('BPMS', Timing)
    stops = _parameter_property('STOPS', Timing)
    offset = _parameter_property('OFFSET', Decimal)
    credit = _parameter_property('CREDIT')
    genre = _parameter_property('GENRE')
    displaybpm = _parameter_property('DISPLAYBPM')

    def __init__(self, file=None, msd=None):
        super().__init__()
        if not file and not msd:
            self._parameters = SMParameters()
            self._charts = SMCharts()
            return
        elif file and msd:
            raise ValueError('too many arguments to Simfile.__init__')
        elif file:
            if isinstance(file, io.TextIOBase):
                # Get filename from file object
                self._filename = file.name
            else:
                # Argument isn't a filename or a file
                raise TypeError('SMSimfile.__init__ takes a filename or file')
            msd = MSDParser(file)
        elif msd:
            self._filename = None
        
        msd_tee = itertools.tee(msd)
        self._parameters = SMParameters.from_msd(msd_tee[0])
        self._charts = SMCharts.from_msd(msd_tee[1])

    def to_msd(self):
        yield from self.parameters.to_msd()
        yield from self.charts.to_msd()

    @classmethod
    def from_msd(cls, msd):
        return cls(msd=msd)

    @classmethod
    def from_string(cls, string):
        """Construct a Simfile from a string that contains simfile data."""
        return cls.from_msd(MSDParser(string))

    def save(self, filename=None):
        """
        Write the simfile to the filesystem.

        If the `filename` argument is given, it is used. If omitted, the
        simfile will be written to the file from which it was originally read,
        or a ``ValueError`` will be raised if it was read from a string.
        """
        filename = filename or self.filename
        if not filename:
            raise ValueError('no filename provided')
        with codecs.open(filename, 'w', 'utf-8') as output:
            for parameter in self.to_msd():
                output.write('#' + ':'.join(parameter) + ';\n')

    @property
    def filename(self):
        return self._filename

    @property
    def parameters(self):
        return self._parameters
    
    @property
    def charts(self):
        return self._charts

    def __repr__(self):
        rtn = '<SMSimfile'
        if self.title:
            rtn += ': ' + self.title
            if self.subtitle:
                subtitle = self.subtitle
                if subtitle[0] not in '[({' or subtitle[-1] not in '])}':
                    subtitle = '(' + subtitle + ')'
                rtn += ' ' + subtitle
        return rtn + '>'

    def __eq__(self, other):
        """
        Test for equality with another Simfile.

        This only compares the parameters and charts, not the filenames or any
        other Simfile object attributes.
        """
        return (type(self) is type(other) and
                self.parameters == other.parameters and
                self.charts == other.charts)